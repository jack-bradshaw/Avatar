package com.matthewtamlin.avatar.rules;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.testing.compile.JavaFileObjects;
import com.matthewtamlin.avatar.compilation.CompilationResult;
import com.matthewtamlin.avatar.compilation.CompilerUtil;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import java.io.File;
import java.lang.annotation.Annotation;
import java.net.MalformedURLException;
import java.util.*;

import static com.matthewtamlin.avatar.util.IterableNullChecker.checkNotContainsNull;
import static com.matthewtamlin.java_utilities.checkers.NullChecker.checkNotNull;

/**
 * A test rule for compiling Java source code before testing. Once applied, the rule provides access to: <ul> <li>The
 * {@link ProcessingEnvironment} used during compilation.</li> <li>The {@link CompilationResult}.</li> <li>The {@link
 * RoundEnvironment}s generated by compilation.</li> <li>The {@link Element}s generated by compilation.</li></ul>
 * <p>
 * There are three mechanisms for getting the elements generated by compilation: <ul> <li>Annotate elements with {@link
 * ElementId} and call {@link #getElementsWithId(String)} or {@link #getElementWithUniqueId(String)}.</li> <li>Annotate
 * elements with any annotation and call {@link #getElementsWithAnnotation(Class)}.</li> <li>Call {@link
 * #getRootElements()}.</li></ul>
 */
public class AvatarRule implements TestRule {
	/**
	 * The sources to compile.
	 */
	private final Iterable<JavaFileObject> sources;
	
	/**
	 * If true, compilation must succeed without error.
	 */
	private final boolean requireSuccessfulCompilation;
	
	/**
	 * The round environments generated by compilation, in the order that they were generated.
	 */
	private final List<RoundEnvironment> roundEnvironments = new ArrayList<>();
	
	/**
	 * The root elements generated by compilation.
	 */
	private final Set<Element> rootElements = new HashSet<>();
	
	/**
	 * All elements that were generated by compilation with at least one annotation. Each key is the fully qualified
	 * name
	 * of an annotation, and the corresponding value is the set of elements that possess that annotation.
	 */
	private final Map<String, Set<Element>> elementsByAnnotationName = new HashMap<>();
	
	/**
	 * All elements that were generated by compilation with an {@link ElementId} annotation. Each key is an element ID,
	 * and the corresponding value is the set of elements with that ID.
	 */
	private final Map<String, Set<Element>> elementsById = new HashMap<>();
	
	/**
	 * The processing environment supplied by the system during compilation.
	 */
	private ProcessingEnvironment processingEnvironment;
	
	/**
	 * The result produced by compiling the sources.
	 */
	private CompilationResult compilationResult;
	
	private AvatarRule(final Builder builder) {
		this.sources = ImmutableList.copyOf(builder.sources);
		this.requireSuccessfulCompilation = builder.requireSuccessfulCompilation;
	}
	
	@Override
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				compilationResult = CompilerUtil.compileUsingProcessor(new AvatarRule.Processor(), sources);
				
				if (requireSuccessfulCompilation && !compilationResult.success()) {
					throw new RuntimeException("Compilation failed. Use Builder" +
							".withSuccessfulCompilationRequired(boolean) to ignore errors.");
				}
				
				base.evaluate();
			}
		};
	}
	
	/**
	 * Gets the processing environment supplied by the system during compilation.
	 *
	 * @return the processing environment, not null
	 *
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public ProcessingEnvironment getProcessingEnvironment() {
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing processing environment.");
		}
		
		return processingEnvironment;
	}
	
	/**
	 * Gets the result of compilation.
	 *
	 * @return the result, not null
	 *
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public CompilationResult getCompilationResult() {
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing compilation result.");
		}
		
		return compilationResult;
	}
	
	/**
	 * Gets the round environments generated by compilation.
	 *
	 * @return the round environments, may be empty, not null
	 *
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public List<RoundEnvironment> getRoundEnvironments() {
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing round environments.");
		}
		
		return roundEnvironments;
	}
	
	/**
	 * Gets all elements generated by compilation that match with the supplied ID. The ID of an element is defined by
	 * applying the {@link ElementId} annotation.
	 *
	 * @param id
	 * 		the ID to match with, not null
	 *
	 * @return the elements, may be empty, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Set<Element> getElementsWithId(final String id) {
		checkNotNull(id, "Argument \'id\' cannot be null.");
		
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		if (elementsById.containsKey(id)) {
			return elementsById.get(id);
		} else {
			return new HashSet<>();
		}
	}
	
	/**
	 * Gets the element generated by compilation that matches with the supplied ID. The ID of an element is defined by
	 * applying the {@link ElementId} annotation. An exception will be thrown if no matches are found or multiple
	 * matches
	 * are found.
	 *
	 * @param id
	 * 		the ID to match with, not null
	 *
	 * @return the element, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 * @throws UniqueElementNotFoundException
	 * 		if no matches are found or multiple matches are found
	 */
	public Element getElementWithUniqueId(final String id) {
		checkNotNull(id, "Argument \'id\' cannot be null.");
		
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		if (getElementsWithId(id).isEmpty()) {
			throw new UniqueElementNotFoundException("No elements found for ID \'" + id + "\'.");
		}
		
		if (getElementsWithId(id).size() > 1) {
			throw new UniqueElementNotFoundException("Multiple elements found for ID \'" + id + "\'.");
		}
		
		return getElementsWithId(id).iterator().next();
	}
	
	/**
	 * Gets all elements generated by compilation that are annotated with the supplied annotation.
	 *
	 * @param annotationClass
	 * 		the class of the annotation, not null
	 *
	 * @return the elements, may be empty, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Set<Element> getElementsWithAnnotation(Class<? extends Annotation> annotationClass) {
		checkNotNull(annotationClass, "Argument \'annotationClass\' cannot be null.");
		
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		if (elementsByAnnotationName.containsKey(annotationClass.getCanonicalName())) {
			return elementsByAnnotationName.get(annotationClass.getCanonicalName());
		} else {
			return new HashSet<>();
		}
	}
	
	/**
	 * Gets all root elements generated by compilation. A root element is any element at the top level of a source file.
	 *
	 * @return the elements, may be empty, not null
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code id} is null
	 * @throws IllegalStateException
	 * 		if the rule has not been applied or compilation is still in progress
	 */
	public Set<Element> getRootElements() {
		if (compilationResult == null) {
			throw new IllegalStateException("Rule must be evaluated before accessing elements.");
		}
		
		return rootElements;
	}
	
	/**
	 * A processor which collects elements and other important objects during compilation, and assigns them to the
	 * member
	 * variables of the AvatarRule.
	 */
	private class Processor extends AbstractProcessor {
		@Override
		public synchronized void init(final ProcessingEnvironment processingEnvironment) {
			super.init(processingEnvironment);
			AvatarRule.this.processingEnvironment = processingEnvironment;
		}
		
		@Override
		public Set<String> getSupportedAnnotationTypes() {
			return ImmutableSet.of("*");
		}
		
		@Override
		public boolean process(
				final Set<? extends TypeElement> annotations,
				final RoundEnvironment roundEnvironment) {
			
			roundEnvironments.add(roundEnvironment);
			rootElements.addAll(roundEnvironment.getRootElements());
			
			collectElementsByAnnotation(annotations, roundEnvironment);
			collectElementsById(roundEnvironment);
			
			return false;
		}
		
		/**
		 * Maps the elements in the supplied round environment to the supplied annotations. The mappings are added to
		 * the
		 * {@link AvatarRule#elementsByAnnotationName} map.
		 *
		 * @param annotations
		 * 		the annotations to map, not null
		 * @param roundEnvironment
		 * 		contains the elements to map, not null
		 */
		private void collectElementsByAnnotation(
				final Set<? extends TypeElement> annotations,
				final RoundEnvironment roundEnvironment) {
			
			for (final TypeElement annotation : annotations) {
				final String annotationName = annotation.getQualifiedName().toString();
				
				if (!elementsByAnnotationName.containsKey(annotationName)) {
					elementsByAnnotationName.put(annotationName, new HashSet<Element>());
				}
				
				elementsByAnnotationName
						.get(annotationName)
						.addAll(roundEnvironment.getElementsAnnotatedWith(annotation));
			}
		}
		
		/**
		 * Maps the elements in the supplied round environment to their IDs. The mappings are added to the {@link
		 * AvatarRule#elementsById} map. Elements with no ID are ignored.
		 *
		 * @param roundEnvironment
		 * 		contains the elements to map, not null
		 */
		private void collectElementsById(final RoundEnvironment roundEnvironment) {
			for (final Element e : roundEnvironment.getElementsAnnotatedWith(ElementId.class)) {
				final ElementId elementId = e.getAnnotation(ElementId.class);
				final String id = elementId.value();
				
				if (!elementsById.containsKey(id)) {
					elementsById.put(id, new HashSet<Element>());
				}
				
				elementsById.get(id).add(e);
			}
		}
	}
	
	/**
	 * Builds AvatarRule instances.
	 */
	public static class Builder {
		/**
		 * The sources to compile. Must be non-null before building AvatarRule.
		 */
		private Iterable<JavaFileObject> sources;
		
		/**
		 * If true, compilation must succeed without error.
		 */
		private boolean requireSuccessfulCompilation = true;
		
		/**
		 * Constructs a new AvatarRule based on the values provided to this builder.
		 *
		 * @return the new AvatarRule, not null
		 */
		public AvatarRule build() {
			checkNotNull(sources, "Sources must be provided before AvatarRule can be built.");
			
			return new AvatarRule(this);
		}
		
		public Builder withSourceFileObjects(final Iterable<JavaFileObject> sources) {
			if (sources == null) {
				this.sources = null;
				
				return this;
			}
			
			checkNotContainsNull(sources, "Argument \'sources\' cannot contain null.");
			
			this.sources = sources;
			
			return this;
		}
		
		public Builder withSourceFileObjects(final JavaFileObject... sources) {
			if (sources == null) {
				this.sources = null;
				
				return this;
			}
			
			return withSourceFileObjects(Arrays.asList(sources));
		}
		
		public Builder withSourceFiles(final Iterable<File> sources) {
			if (sources == null) {
				this.sources = null;
				
				return this;
			}
			
			final List<JavaFileObject> javaFileObjects = new ArrayList<>();
			
			for (final File source : sources) {
				checkNotNull(source, "Argument \'sources\' cannot contain null.");
				
				if (!source.exists()) {
					throw new IllegalArgumentException("File \'" + source + "\' does not exist.");
				}
				
				try {
					javaFileObjects.add(JavaFileObjects.forResource(source.toURI().toURL()));
				} catch (final MalformedURLException e) {
					throw new RuntimeException("Could not get URL for file \'" + source + "\'.", e);
				}
			}
			
			return withSourceFileObjects(javaFileObjects);
		}
		
		public Builder withSourceFiles(final File... sources) {
			if (sources == null) {
				this.sources = null;
				
				return this;
			}
			
			return withSourceFiles(Arrays.asList(sources));
		}
		
		public Builder withSourcesAt(final Iterable<String> sourcePaths) {
			if (sourcePaths == null) {
				sources = null;
				
				return this;
			}
			
			final List<File> files = new ArrayList<>();
			
			for (final String sourcePath : sourcePaths) {
				checkNotNull(sourcePath, "Argument \'sourcePaths\' cannot contain null.");
				
				final File sourceFile = new File(sourcePath);
				
				if (!sourceFile.exists()) {
					throw new IllegalArgumentException("File \'" + sourceFile + "\' does not exist.");
				}
				
				files.add(sourceFile);
			}
			
			return withSourceFiles(files);
		}
		
		public Builder withSourcesAt(final String... sourcePaths) {
			if (sourcePaths == null) {
				sources = null;
				
				return this;
			}
			
			return withSourcesAt(Arrays.asList(sourcePaths));
		}
		
		public Builder withSuccessfulCompilationRequired(final boolean required) {
			requireSuccessfulCompilation = required;
			
			return this;
		}
	}
}